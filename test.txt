//实验二问题A
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<string>
#include<cmath>
#include<vector>
#include<queue>
using namespace std;
  
#define Int __int64
#define INF 0x3f3f3f3f
  
const int MAXN = 555;
int n, m, s, e;
  
int maze[MAXN][MAXN];
int dis[MAXN];
bool vis[MAXN];
int score[MAXN];
int ans[MAXN];
  
void init() {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (i == j) maze[i][j]  = 0;
            else maze[i][j] = INF;
        }
    }
    memset(dis, 0, sizeof(dis));
    memset(vis, false, sizeof(vis));
    memset(ans, false, sizeof(ans));
}
  
void Dijkstra() {
    for (int i = 0; i < n; i++) {
        scanf("%d", &score[i]);
    }
  
    int u, v, w;
    for (int i = 0; i < m; i++) {
        scanf("%d %d %d", &u, &v, &w);
        if (w < maze[u][v]) {
            maze[u][v] = w;
            maze[v][u] = w;
        }
    }
  
    for (int i = 0; i < n; i++) {
        dis[i] = maze[s][i];
        if (i != s) ans[i] = score[s] + score[i];//初始化的时候也要判断等于的情况
        else ans[i] = score[i];
    }
  
    for (int i = 0; i < n; i++) {
  
        int pos, Min = INF;
        for (int a = 0; a < n; a++) {
            if (vis[a]) continue;
            if (dis[a] < Min) {
                Min = dis[a];
                pos = a;
            }
        }
        vis[pos] = true;
  
        for (int a = 0; a < n; a++) {
  
            if (maze[pos][a] < INF) {
                if (dis[a] > dis[pos] + maze[pos][a]) {
                    dis[a] = dis[pos] + maze[pos][a];
                    ans[a] = ans[pos] + score[a];
                } else if ((dis[a] == dis[pos] + maze[pos][a]) && (ans[a] < ans[pos] + score[a]) && pos != a) {/*就是这里要判断等于的时候是不行的*/
                    ans[a] = ans[pos] + score[a];
                } else {
                    continue;
                }
            }
        }
    }
}
int main()
{
  
    while (scanf("%d %d %d %d", &n, &m, &s, &e) != EOF) {
        init();
        Dijkstra();
        printf("%d %d\n", dis[e], ans[e]);
    }
    return 0;
}
